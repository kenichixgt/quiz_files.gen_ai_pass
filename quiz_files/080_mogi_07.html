<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>生成AIパスポート模擬問題7</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f4f7f9;
            margin: 0;
            padding: 20px;
        }
        .container {
            max-width: 900px;
            margin: auto;
            background: #fff;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }
        h1, h2 {
            color: #1e3a5f;
            border-bottom: 2px solid #e2e8f0;
            padding-bottom: 10px;
        }
        h2 {
            margin-top: 40px;
        }
        #score-board {
            background-color: #eef4ff;
            border: 1px solid #d4e2f4;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            display: flex;
            justify-content: space-around;
            font-weight: bold;
            color: #1e3a5f;
        }
        #filter-controls {
            margin: 20px 0;
        }
        .filter-button {
            padding: 8px 15px;
            font-size: 14px;
            border: 1px solid #007bff;
            background-color: #fff;
            color: #007bff;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s, color 0.3s;
            margin-right: 5px;
        }
        .filter-button:hover, .filter-button.active {
            background-color: #007bff;
            color: white;
        }
        .question-block {
            background: #fafcff;
            border: 1px solid #d4e2f4;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 25px;
            transition: box-shadow 0.3s ease;
            position: relative;
        }
        .question-block:hover {
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
        }
        .flag-button {
            position: absolute;
            top: 15px;
            right: 15px;
            font-size: 20px;
            cursor: pointer;
            background: none;
            border: none;
            padding: 5px;
            opacity: 0.5;
        }
        .flag-button.flagged {
            opacity: 1.0;
        }
        .question-title {
            font-weight: bold;
            font-size: 1.1em;
            margin-bottom: 15px;
            color: #3b5998;
            padding-right: 30px; /* Make space for flag button */
        }
        .options label {
            display: block;
            margin: 10px 0;
            cursor: pointer;
            transition: color 0.2s;
        }
        .options label:hover {
            color: #0056b3;
        }
        .answer-section {
            display: none;
            margin-top: 20px;
            padding-top: 15px;
            border-top: 2px dashed #e2e8f0;
        }
        .answer-header {
            font-weight: bold;
            color: #007bff;
            margin-bottom: 5px;
        }
        .answer-correct, .answer-incorrect {
            font-weight: bold;
        }
        .answer-correct {
            color: #28a745;
        }
        .answer-incorrect {
            color: #dc3545;
        }
        .explanation {
            margin-top: 10px;
            color: #555;
        }
        .grade-button, .export-button, .import-button, .clear-button {
            padding: 10px 20px;
            font-size: 16px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
            margin-right: 10px;
        }
        .grade-button { background-color: #007bff; color: white; }
        .grade-button:hover { background-color: #0056b3; }
        .export-button { background-color: #28a745; color: white; }
        .export-button:hover { background-color: #218838; }
        .import-button { background-color: #ffc107; color: #333; }
        .import-button:hover { background-color: #e0a800; }
        .clear-button { background-color: #dc3545; color: white; }
        .clear-button:hover { background-color: #c82333; }
        .status-message { margin-top: 10px; font-weight: bold; color: #333; }
        #import-input { margin-top: 10px; width: 100%; padding: 8px; box-sizing: border-box; border: 1px solid #ccc; border-radius: 4px; }
    </style>
</head>
<body>

<div class="container">
    <h1>生成AIパスポート模擬問題7</h1>
    
    <div id="score-board">
        <span>正答数: <span id="correct-count">0</span></span>
        <span>回答数: <span id="answered-count">0</span></span>
        <span>正解率: <span id="accuracy-rate">0.0</span>%</span>
    </div>

    <div id="controls">
        <button class="export-button" onclick="exportState()">結果をエクスポート</button>
        <button class="import-button" onclick="showImport()">結果をインポート</button>
        <button class="clear-button" onclick="clearState()">回答をクリア</button>
        <div id="import-area" style="display:none;">
            <input type="text" id="import-input" placeholder="ここにエクスポートしたコードを貼り付けてください">
            <button class="import-button" onclick="importState()">インポート実行</button>
            <div id="status-message" class="status-message"></div>
        </div>
    </div>
    
    <div id="filter-controls">
        <strong>フィルター:</strong>
        <button class="filter-button active" onclick="applyFilter('all')">全て表示</button>
        <button class="filter-button" onclick="applyFilter('flagged')">フラグ</button>
        <button class="filter-button" onclick="applyFilter('unanswered')">未回答</button>
        <button class="filter-button" onclick="applyFilter('correct')">正答</button>
        <button class="filter-button" onclick="applyFilter('incorrect')">誤答</button>
    </div>

    <div id="quiz-container"></div>
</div>

<script>
    const quizData = [
        {
            "section": "生成AIパスポート模擬問題7",
            "questions": [
                {
                    "q": "AI（人工知能）の一般的定義として最も適切なのはどれか。人間の知的活動を機械が模倣する枠組み全般を指すが、自己意識の有無は前提ではない。",
                    "options": [
                        "データから学習し予測・判断する技術群",
                        "自己意識をもつ自立機械のみ",
                        "物理作業を行うロボット全般",
                        "人間の脳構造を完全再現した装置"
                    ],
                    "answer": 0,
                    "explanation": "AIは「人が行う知的な働き（学習・推論・判断・予測など）を、データとアルゴリズムで実現する広い技術の総称」です。自己意識の有無やロボットの形をしているかは条件ではありません。②は「自己意識」を前提にしており過剰、③は“物理作業をする機械（ロボット）”をAIと同一視していて範囲が狭すぎ、④は「脳を完全再現」という不要な条件を含むため不適切です。①が最も中立で実務的な定義です。"
                },
                {
                    "q": "「知能をもたらす2つの仕組み」を整理したときの典型的な区分として正しい組合せはどれか。",
                    "options": [
                        "物理演算と量子計算",
                        "ルールベースと機械学習",
                        "強化学習と転移学習",
                        "画像認識と音声認識"
                    ],
                    "answer": 1,
                    "explanation": "AIの作り方は大きく「ルールベース（人間がIf-Then等の規則を明示）」と「機械学習（データから規則を自動獲得）」に分けられます。現場では両者を組み合わせる例も多いです。①は計算手段の種類で“知能の仕組み”ではなく、③は両方とも機械学習の一部、④は“用途別の処理”で仕組みの分類ではありません。"
                },
                {
                    "q": "ルールベースAIの限界として最も本質的な指摘はどれか。",
                    "options": [
                        "学習データの収集が困難",
                        "教師なし学習に向かない",
                        "未知事例に弱く保守が肥大化",
                        "並列計算ができない"
                    ],
                    "answer": 2,
                    "explanation": "ルールベースは“想定済みの状況”には強い一方、想定外に出会うと対応ルールがなく破綻しがちで、追加修正を繰り返すと保守が雪だるま式に増えます。これが「未知事例に弱い」「保守が肥大化」の本質です。①は学習データの話でルールベースの本質ではなく、②は的外れ、④は並列計算の可否であって限界の核心ではありません。"
                },
                {
                    "q": "教師あり学習の基本要件として正しいものはどれか。",
                    "options": [
                        "報酬設計が必要",
                        "入力の自己回帰が必須",
                        "ラベルは不要",
                        "入力と正解ラベルの組を用意"
                    ],
                    "answer": 3,
                    "explanation": "教師あり学習は「入力と正解ラベルのペア」を使い、誤差が小さくなるようモデルを調整します。したがって④が本質です。①の報酬は強化学習の概念、②はモデル構造の話で必須ではなく、③は“教師あり”の定義に反します。"
                },
                {
                    "q": "教師なし学習の代表的タスクとして最も適切なのはどれか。",
                    "options": [
                        "回帰予測",
                        "意味役割付与",
                        "クラスタリング",
                        "強化方策学習"
                    ],
                    "answer": 2,
                    "explanation": "教師なし学習は“正解の付いていないデータから構造を見つける”手法群です。代表例がクラスタリング（似たデータのグループ分け）と次元削減です。①の回帰は教師あり、②は特定の言語処理手法、④は強化学習の用語でいずれも不適切です。"
                },
                {
                    "q": "過学習（オーバーフィッティング）の典型症状はどれか。",
                    "options": [
                        "訓練も未知も高精度",
                        "訓練高精度だが未知で劣化",
                        "未知のみ高精度",
                        "訓練のみ低精度"
                    ],
                    "answer": 1,
                    "explanation": "過学習は「訓練データにだけ極端に強く適合し、初見データの成績が下がる」現象です。現場では“訓練精度↑・検証精度↓”の乖離で気づきます。対策は正則化、ドロップアウト、データ拡張、早期終了、検証データの活用など。②が典型パターンで正解です。"
                },
                {
                    "q": "転移学習が有効になりやすい状況はどれか。",
                    "options": [
                        "データが極端に均質",
                        "タスクが無関連",
                        "特徴が近い下流タスク",
                        "学習済みが存在しない"
                    ],
                    "answer": 2,
                    "explanation": "転移学習は「既存モデルが学んだ特徴を別の近い課題に再利用する」考え方です。例えば犬猫分類で学んだ“エッジや模様”の特徴を別の動物分類に流用するイメージです。③のように“特徴が近い下流タスク”で効果が出やすい。①②は前提が合わず、④は“学習済みがない”ので転移のしようがありません。"
                },
                {
                    "q": "「AIの4つのレベル」の理解として適切なのはどれか。",
                    "options": [
                        "すべて汎用AIを指す",
                        "物理ロボットに限定",
                        "ルール数で段階づけ",
                        "認識→理解→判断→行動などの能力段階"
                    ],
                    "answer": 3,
                    "explanation": "「AIの4つのレベル」は“AIがどこまでできるか”を段階で整理する枠組みで、認識→理解→判断→行動のように能力が広がるほどレベルが上がります。特定のロボット形態やルール数で決まるわけではありません。したがって④が適切です。"
                },
                {
                    "q": "弱いAI（ANI）と強いAI（AGI）の区別で正しいのはどれか。",
                    "options": [
                        "ANIは万能、AGIは特化",
                        "AGIは特定課題専用",
                        "ANIは特定領域、AGIは汎用",
                        "どちらも同義"
                    ],
                    "answer": 2,
                    "explanation": "ANI（弱いAI）は“特定領域に特化した賢さ”（例：翻訳、囲碁など）。AGI（強いAI）は“多様な課題を柔軟にこなせる汎用知能”を指します。実務で使う多くのAIはANIです。選択肢③が定義に合致します。"
                },
                {
                    "q": "第一次・第二次・第三次AIブームの主軸に関する並びとして最も妥当なのはどれか。",
                    "options": [
                        "機械学習→探索推論→知識",
                        "知識→探索推論→機械学習",
                        "探索推論→知識→機械学習",
                        "知識→機械学習→探索推論"
                    ],
                    "answer": 2,
                    "explanation": "AIの歴史は「第一次：探索・推論」「第二次：知識工学（エキスパートシステム）」「第三次：機械学習・深層学習＋ビッグデータ」が大枠です。よって③（探索推論→知識→機械学習）の順が正しい並びです。"
                },
                {
                    "q": "VAE・GAN・Transformerの関係整理として最も正しい説明はどれか。",
                    "options": [
                        "すべて識別器",
                        "すべて生成モデル系",
                        "すべて強化学習器",
                        "すべて逐次最適化器"
                    ],
                    "answer": 1,
                    "explanation": "VAE（変分オートエンコーダ）とGAN（生成敵対ネットワーク）は“新しいデータを作る”生成モデル、Transformerは“生成も理解も”支える現代NLP/マルチモーダルの土台構造です。いずれも「生成」に関わる技術群で②が妥当。①③④は性質が異なります。"
                },
                {
                    "q": "自己回帰型デコーダーモデルの長所として適切なのはどれか。",
                    "options": [
                        "将来トークンを同時生成",
                        "因果マスクで逐次生成が得意",
                        "画像のみ処理可能",
                        "教師なし学習不可"
                    ],
                    "answer": 1,
                    "explanation": "自己回帰デコーダは「これまでに生成したトークンを条件に、次のトークンを一つずつ出す」方式です。未来情報は見ないよう“因果マスク”を使うのがポイント。したがって②が長所の説明として正解。①は並列生成の説明で逆、③④は守備範囲・学習法の誤りです。"
                },
                {
                    "q": "RNNとTransformerの比較として正しい記述はどれか。",
                    "options": [
                        "RNNは長依存に強い",
                        "Transformerは注意機構で長依存処理",
                        "両者とも畳み込み必須",
                        "どちらも順序情報を扱えない"
                    ],
                    "answer": 1,
                    "explanation": "：RNNは時系列を順番に処理するため長い依存関係が苦手（勾配消失/爆発）になりがちです。Transformerは自己注意（Attention）で遠い単語同士の関係も直接見られ、長依存に強いのが特徴。よって②が正しい。①④は逆、③はどちらも畳み込み必須ではありません。"
                },
                {
                    "q": "RLHF（人間のフィードバックによる強化学習）の目的として最も適切なのはどれか。",
                    "options": [
                        "モデルの速度向上",
                        "モデル出力の人間嗜好への整合",
                        "学習データの匿名化",
                        "トークン化の改良"
                    ],
                    "answer": 1,
                    "explanation": "RLHFは人が“好ましい/好ましくない”と評価した例から報酬モデルを作り、その報酬が高くなるよう生成AIを微調整して“人間の期待に沿う”よう整える方法です。速度や匿名化、トークン化の改良とは目的が異なります。②が要点を押さえています。"
                },
                {
                    "q": "ハルシネーション対策として有効な運用はどれか。",
                    "options": [
                        "出力を鵜呑み",
                        "モデル温度を常に最大",
                        "ツール・外部検索の併用",
                        "学習率を下げる"
                    ],
                    "answer": 2,
                    "explanation": "ハルシネーションは“ありそうに聞こえる誤情報”を自信満々に出してしまう問題です。実務では外部検索や自社データの参照（RAG）、計算ツールやデータベース連携で根拠を取りに行く運用が有効です。温度や学習率だけでは本質解決になりません。③が実践的対応です。"
                },
                {
                    "q": "ChatGPTにおける「Code Interpreter」（現・高度なデータ解析）の核心機能を最も端的に表すのはどれか。",
                    "options": [
                        "ブラウザ拡張",
                        "音声合成",
                        "プロンプト管理",
                        "安全な一時実行環境での計算・可視化"
                    ],
                    "answer": 3,
                    "explanation": "「Code Interpreter（高度なデータ解析）」はサンドボックス環境でPython等を実行し、データの前処理、集計、可視化、簡単なモデリング、ファイル入出力まで一気通貫で行える機能です。ブラウズ機能や音声合成とは別物で、④が最も的確です。"
                },
                {
                    "q": "GPTs（カスタムGPT）の活用設計で重要度が最も高いのはどれか。",
                    "options": [
                        "モデルの隠し設定を増やす",
                        "画像生成を常に有効化",
                        "目的・入出力仕様の明確化",
                        "外部ツールは使わない"
                    ],
                    "answer": 2,
                    "explanation": "カスタムGPTを成功させるカギは“何のために・誰向けに・どの入力を受け・どんな形式で出すか”を明確にすることです。目的と入出力仕様が定義できていないと、設定を盛っても品質は安定しません。よって③が最重要。"
                },
                {
                    "q": "マルチモーダル化の利点として妥当なのはどれか。",
                    "options": [
                        "言語能力は不要",
                        "画像のみ高精度化",
                        "相互補完で理解精度向上",
                        "処理は必ず遅くなる"
                    ],
                    "answer": 2,
                    "explanation": "マルチモーダルはテキスト・画像・音声など異種データを組み合わせ、互いの弱点を補い合って理解精度や頑健性を高めます。画像だけが良くなるわけでも、必ず遅くなるわけでもありません。③が要点を表しています。"
                },
                {
                    "q": "生成AIサービス選定で重視すべき観点として最も適切なのはどれか。",
                    "options": [
                        "モデル名の知名度のみ",
                        "価格が最安であることのみ",
                        "目的適合・安全性・運用性",
                        "ベンチマーク一点の数値"
                    ],
                    "answer": 2,
                    "explanation": "要件適合、法令・規約順守、拡張性やSLAなど総合評価が必要。"
                },
                {
                    "q": "【時事】Gemini 2.5 Proは2025年に段階提供された。正しい記述はどれか。",
                    "options": [
                        "2025年1月にGA化",
                        "2025年3月にGA化",
                        "2025年6月にGA化",
                        "2025年9月に初公開"
                    ],
                    "answer": 2,
                    "explanation": "Gemini 2.5 Proは「2025年3月に発表→同年6月に一般提供（GA）開始」というタイムラインです。したがって“6月にGA化”の③が正解。①②は時期が早すぎ、④は初公開の月が誤りです。時系列を押さえるのがコツです。"
                },
                {
                    "q": "ディープフェイク（深層偽造）の不適切利用に該当する例として最も適切なものはどれか。AIで人物の顔や声を生成したコンテンツの利用場面に注目して判断せよ。",
                    "options": [
                        "研究目的で手法を検証する",
                        "本人同意なく名誉を傷つける偽動画を拡散する",
                        "授業で作例として短時間上映する",
                        "映画のVFXとして制作に使う"
                    ],
                    "answer": 1,
                    "explanation": "ディープフェイクの“問題”は技術そのものよりも「どう使うか」にあります。②のように、本人の同意なく名誉を傷つける偽動画を作って拡散するのは、プライバシー侵害・名誉毀損・肖像権侵害など多くのリスクがあり、典型的な不適切利用です。①の研究は倫理審査やデータ取り扱いに配慮すれば適法・適切に実施し得ます。③の教育利用は出典・加工の明示や権利配慮を前提に限定的に扱えば直ちに不適切とは限りません。④の映画VFXは一般に合成表現であり、出演契約や権利処理があれば適切利用に該当します。"
                },
                {
                    "q": "音声生成AIのリスクとして最も重要なものはどれか。",
                    "options": [
                        "サンプリング周波数の低下",
                        "声のなりすましによる詐欺",
                        "拡張子の互換性不足",
                        "自動正規化の失敗"
                    ],
                    "answer": 1,
                    "explanation": "音声生成AIの最大の社会的リスクは“本人になりすませる”点です。②は、家族や上司の声になりすました詐欺・指示偽装（ボイスフィッシング）を想定しており、被害につながりやすい本質的な危険です。①③④は品質や処理の話で、犯罪に直結する重大性は相対的に低いです。実務では「本人確認の二要素化」「声紋よりも合言葉や別チャネル確認」を導入するのが有効です。"
                },
                {
                    "q": "画像生成AIの基礎モデルの位置付けとして適切なのはどれか。",
                    "options": [
                        "VAEとGANが基礎的土台",
                        "RNNが唯一の基礎",
                        "BERTが標準基盤",
                        "物理シミュレータが必須"
                    ],
                    "answer": 0,
                    "explanation": "画像生成の基礎としてよく学ぶのがVAEとGANです。VAEは“圧縮した潜在表現”から画像を再構成し、GANは“生成器と識別器の対立学習”でリアルな画像を作ります。Stable Diffusionのような近年のモデル理解にもこれらの考え方が通底します。②のRNNや③のBERTは主に系列/言語の文脈、④の物理シミュレーションは別領域です。"
                },
                {
                    "q": "次のうち「動画生成AI」の例として正しい組合せはどれか。",
                    "options": [
                        "BERT／Whisper／CLIP",
                        "DALL·E／Midjourney／Stable Diffusion",
                        "Sora／Runway Gen-3／Luma Dream Machine",
                        "GPT-2／VAE／ResNet"
                    ],
                    "answer": 2,
                    "explanation": "動画生成AIは「テキストや画像から“動画”を直接生成」する技術です。③のSora／Runway Gen-3／Luma Dream Machineはいずれも動画生成の代表例。②は主に静止画生成、①は言語・音声・視覚表現の基盤モデル群、④は基礎的な学習手法/アーキテクチャの混在で動画生成の列挙ではありません。用途（静止画か動画か）で見分けましょう。"
                },
                {
                    "q": "悪質なQRコードに潜む典型的な危険はどれか。",
                    "options": [
                        "画像解像度の劣化",
                        "フィッシングサイトへの誘導",
                        "端末の発熱増大",
                        "バッテリー劣化の促進"
                    ],
                    "answer": 1,
                    "explanation": "悪質なQRコードの典型は「正規サイトに見せかけて偽サイトへ誘導」する手口です。②が該当し、ログイン情報や決済情報の詐取につながります。読み取る前に“URLのプレビュー確認”“短縮URLの展開”“公式アプリからのアクセス”などで防げます。①③④は直接的な被害説明として不適切です。"
                },
                {
                    "q": "公衆Wi-Fiの「罠」として代表的な脅威はどれか。",
                    "options": [
                        "TLS証明書の自動更新",
                        "帯域制限の緩和",
                        "中間者攻撃による盗聴",
                        "DNSキャッシュ増加"
                    ],
                    "answer": 2,
                    "explanation": "公衆Wi-Fiでは“誰でも同じ電波に乗る”ため、攻撃者が通信の間に入り込む「中間者攻撃（MITM）」が起きやすく、③が本質的脅威です。偽アクセスポイント（なりすましAP）や暗号化なしの接続は特に危険。対策は「VPNの利用」「HTTPS/TLSの確認」「自動接続オフ」。①②④は脅威の指摘として的外れです。"
                },
                {
                    "q": "ソーシャルエンジニアリングの一種「プレテキスト攻撃」の説明として正しいものはどれか。",
                    "options": [
                        "架空の肩書で信頼を得る",
                        "機器を物理破壊する",
                        "暗号鍵長を短縮する",
                        "モデルを微調整する"
                    ],
                    "answer": 0,
                    "explanation": "プレテキスト攻撃は“もっともらしい肩書や状況（例：社内IT担当、取引先、宅配業者など）を装い”、被害者に情報を自発的に開示させる手口で、①が正解です。技術的ハッキングではなく“心理的なだまし”が中心。②は物理破壊、③は暗号強度の話、④は機械学習の専門用語でいずれも無関係です。本人確認の徹底や手続きの二重化が防御策です。"
                },
                {
                    "q": "SNSのプライバシー設定の基本原則として最も適切なのはどれか。",
                    "options": [
                        "既定で全体公開にする",
                        "位置情報は常時オン",
                        "連絡先は常時自動同期",
                        "最小権限・公開範囲を限定"
                    ],
                    "answer": 3,
                    "explanation": "SNSのプライバシー基本は「最小権限・限定公開」。④のように公開範囲を必要最低限にし、位置情報や連絡先アクセスは“必要なときだけ”付与します。①②③の常時オンや全体公開はリスクが高く、思わぬ個人特定やなりすましにつながります。定期的な設定見直しと、投稿前の“公開範囲の再確認”が実務のコツです。"
                },
                {
                    "q": "「要配慮個人情報」に該当する例として正しいものはどれか。",
                    "options": [
                        "郵便番号",
                        "取引先の会社名",
                        "病歴・信条・人種など",
                        "公開済みの業績"
                    ],
                    "answer": 2,
                    "explanation": "「要配慮個人情報」は差別・不利益につながり得るデリケートな情報で、病歴・信条・人種など③が該当します。通常の氏名・住所等より厳格な取り扱いが必要です。①の郵便番号や②の会社名、④の公表済み実績は一般に該当しません（ただし組み合わせで個人特定につながる場合は別途注意が必要）。"
                },
                {
                    "q": "匿名加工情報の要件として適切なのはどれか。",
                    "options": [
                        "復元可能で個人識別",
                        "統計処理などで識別性を低下",
                        "同意不要で無制限共有",
                        "マスキングは不要"
                    ],
                    "answer": 1,
                    "explanation": "匿名加工情報は“個人が特定されないように加工し、元に戻せないこと”が要点です。②は「統計処理やマスキングで識別性を下げる」という正しい趣旨を表しています。①や④の“復元可能”“マスキング不要”は要件に反します。③の「無制限共有」は、法令やガイドライン上の手続や提供先管理を無視しており不適切です。"
                },
                {
                    "q": "BERTとGPTの主要構成の違いとして正しいものはどれか。",
                    "options": [
                        "どちらも双方向エンコーダ",
                        "どちらもデコーダのみ",
                        "BERTは自己回帰デコーダ",
                        "BERTは双方向エンコーダ、GPTは自己回帰デコーダ"
                    ],
                    "answer": 3,
                    "explanation": "BERTは“文の前後を同時に読む”双方向エンコーダで理解（分類・抽出・埋め込み）に強く、GPTは“左から右へ順に予測する”自己回帰デコーダで生成に強い、という役割分担が基本です。したがって④が正しい対比です。①②③はいずれも構成を取り違えています。用途に応じてモデルを選び分けるのが実務のポイントです。"
                },
                {
                    "q": "位置エンコーディング（Positional Encoding）の主目的はどれか。",
                    "options": [
                        "順序情報をモデルに注入",
                        "学習率を自動調整",
                        "画像解像度を向上",
                        "活性化関数を置換"
                    ],
                    "answer": 0,
                    "explanation": "Transformerは自己注意で単語同士の関係を柔軟に捉えますが、素の注意機構には“順序”の概念がありません。そこで①のとおり、位置エンコーディングでトークンの並び順を数列（正弦波など）で埋め込み、系列性を扱えるようにします。②③④は別の技術要素で目的が異なります。"
                },
                {
                    "q": "Multi-Head Attention の利点として最も適切なのはどれか。",
                    "options": [
                        "計算量をゼロにする",
                        "多様な視点で並列に注意",
                        "勾配消失を完全解決",
                        "行列演算を不要化"
                    ],
                    "answer": 1,
                    "explanation": "Multi-Head Attentionは“注意の視点を分けて並列に学習”できるため、文法関係・語義・参照関係など異なるパターンを同時に捉えられます。よって②が利点の核心です。①③④は誇張や誤りで、計算量がゼロになったり行列演算が不要になったりはしません。多頭化で表現力が増す、と覚えましょう。"
                },
                {
                    "q": "GPT-1／GPT-2／GPT-3 のパラメータ規模として正しい並びはどれか。",
                    "options": [
                        "1.5億／3億／30億",
                        "1.17億／12億／500億",
                        "1.17億／15億／1750億",
                        "1億／10億／100億"
                    ],
                    "answer": 2,
                    "explanation": "GPT系は世代が進むにつれ大規模化しました。GPT-1 ≈1.17億、GPT-2 ≈15億、GPT-3 ≈1750億パラメータで、③が正しい並びです。規模拡大は表現力や汎用性の向上に寄与しましたが、計算資源やコストも増大します。単なる“巨大化”だけでなく、データ・学習手法・指示追従強化の工夫も重要です。"
                },
                {
                    "q": "誤差逆伝播法と勾配降下法の役割として正しいものはどれか。",
                    "options": [
                        "勾配で重みを更新する",
                        "入力データを可逆化する",
                        "出力確率を正規化する",
                        "損失を必ずゼロにする"
                    ],
                    "answer": 0,
                    "explanation": "学習の核は“損失を小さくする”ことです。誤差逆伝播法で各層の勾配（重みをどちらにどれだけ動かせば損失が減るか）を計算し、勾配降下法で実際に重みを更新します。①がそれを端的に表します。②③④はいずれも役割の取り違えまたは誤解です。損失が必ずゼロになるわけではありません。"
                },
                {
                    "q": "CNNの特徴として最も適切なのはどれか。",
                    "options": [
                        "自己注意が中核",
                        "記憶ゲートで長期依存",
                        "Encoder-Decoderが必須",
                        "畳み込みで局所特徴を抽出"
                    ],
                    "answer": 3,
                    "explanation": "CNNは“畳み込み”という処理で、エッジ・模様などの“局所特徴”を見つけ、プーリングでまとめていく構造が特徴です。画像認識で強みを発揮します。④が正解。①の自己注意はTransformer、②はLSTMなどの話、③はEncoder-Decoderが必須ではありません。画像生成でもCNNの考え方は広く使われます。"
                },
                {
                    "q": "良いプロンプトの4要素に含まれる組合せとして正しいものはどれか。",
                    "options": [
                        "Role／Memory／Cache／Seed",
                        "Persona／Dataset／Metric／Guard",
                        "Instruction／Context／Input Data／Output Indicator",
                        "Task／Reward／Policy／Value"
                    ],
                    "answer": 2,
                    "explanation": "良いプロンプトの基本は「何を、どの条件で、どの材料を使い、どんな形式で出させたいか」を明確にすることです。③のInstruction／Context／Input Data／Output Indicatorは、その整理に役立つ“型”。これを満たすと再現性が上がり、ブレが減ります。①②④は一般化された標準枠組みではありません。"
                },
                {
                    "q": "【時事】OpenAIが2025年8月に発表した「GPT-5」について正しい記述はどれか。",
                    "options": [
                        "自動ルーティングは試験段階で既定は手動選択",
                        "スマート・推論・ルーターの統合システム",
                        "マルチモーダルは外部拡張依存で基盤はテキスト中心",
                        "深い推論は別モジュール制、ベースは非対応"
                    ],
                    "answer": 1,
                    "explanation": "GPT-5は「通常の質問に素早く答えるスマートなモデル」「難問に使う深い推論モデル」「会話の種類や難易度、ツール使用の要否に応じて最適に切り替えるリアルタイム・ルーター」の三位一体で動く“統一システム”です。これにより、利用者が都度モデルを選ばなくても自動で最適化された応答が得られます。\nまた、GPT-5はChatGPTだけでなくAPIでも提供され、用途やコストに応じて複数サイズ（例：gpt-5／gpt-5-mini／gpt-5-nano）が用意されています。よって①は誤りです。\n③の「マルチモーダルは外部拡張依存で基盤はテキスト中心」や④の「深い推論は別モジュール制、ベースは非対応」といった記述は、GPT-5の発表された機能やアーキテクチャに反します。"
                },
                {
                    "q": "ChatGPT以外の代表的テキスト生成AIとして適切なのはどれか。",
                    "options": [
                        "Claude",
                        "Midjourney",
                        "Whisper",
                        "Stable Diffusion"
                    ],
                    "answer": 0,
                    "explanation": "ChatGPT以外の代表的テキスト生成AIとしてはAnthropicの「Claude」やGoogleの「Gemini」が挙げられます。①が正解です。②のMidjourneyと④のStable Diffusionは主に画像生成、③のWhisperは音声認識（文字起こし）で、テキスト対話モデルとは用途が異なります。モデル名と得意分野をセットで覚えると混同しません。"
                },
                {
                    "q": "次のうち動画生成AIに該当するものはどれか。",
                    "options": [
                        "Stable Diffusion",
                        "BERT",
                        "Whisper",
                        "Sora"
                    ],
                    "answer": 3,
                    "explanation": "動画生成AIは“テキスト→動画”の生成ができるモデル群です。Sora（④）はその代表例で、与えた指示に沿った短編動画を生成できます。①Stable Diffusionは主に静止画、②BERTは言語理解、③Whisperは音声認識で、いずれも動画生成ではありません。分野（画像・言語・音声・動画）ごとに代表モデルを整理しておきましょう。"
                },
                {
                    "q": "生成AI活用における個人情報の取り扱いで最も適切なのはどれか。入力・出力・保存の各段階での管理方針に着目して選べ。",
                    "options": [
                        "入力前に匿名化・最小化を徹底",
                        "出力だけを監査すれば十分",
                        "保存は端末に平文のまま",
                        "同意は社内で一括代行"
                    ],
                    "answer": 0,
                    "explanation": "個人情報は「入れる前」がいちばんコントロールしやすいので、まず“そもそも入れない（最小化）”“どうしても必要なら匿名化（氏名や社員番号を伏せる・マスキングする）”が基本です。入力時点での絞り込みは、誤生成や漏えいが起きてもダメージを小さくできます。②の“出力だけ監査”は手遅れになりがち、③の平文保存は漏えい時の被害拡大、④は本人同意を省略してよい根拠にはなりません。入→処理→保存の全段で「最小化・暗号化・アクセス制御・ログ」を回すことが実務の鉄則です。"
                },
                {
                    "q": "社内FAQ検索を強化したい。更新が頻繁で学習再実行が負担という条件で最適なのはどれか。",
                    "options": [
                        "追加学習のみ",
                        "RAGで外部データ参照",
                        "温度を下げる",
                        "Few-Shotのみ"
                    ],
                    "answer": 1,
                    "explanation": "社内FAQのように“情報がしょっちゅう更新される”場合は、モデルを毎回再学習するより、RAG（検索連携）で「最新の外部データを都度引く」方が早くて安定します。②はまさにこの運用。①の追加学習だけだと更新のたびにコスト・時間がかかります。③の温度調整や④のFew-Shotは表現の安定化には効いても、古い知識が新しくなるわけではありません。"
                },
                {
                    "q": "初見の社内様式文を自然な語調で数例まねたい。最も適したプロンプト手法はどれか。",
                    "options": [
                        "Zero-Shot",
                        "連続プロンプト",
                        "Few-Shot",
                        "温度最大化"
                    ],
                    "answer": 2,
                    "explanation": "文体や様式を“自然にまねる”には、良い例を少数見せるFew-Shotが近道です。モデルは例から語彙・トーン・構成を推測できます。Zero-Shot（①）はぶれやすく、②の連続プロンプトは段取りには有効でも文体模倣の根拠が不足しがち。④の温度最大化はむしろ散らかります。良いFew-Shotは「良質で短い見本×2〜5件＋出力形式の指定」がコツです。"
                },
                {
                    "q": "ディープフェイク対策の初動として適切なのはどれか。",
                    "options": [
                        "SNSで即時共有",
                        "直感で真偽判断",
                        "画質向上で確認",
                        "出所・改変痕跡の検証"
                    ],
                    "answer": 3,
                    "explanation": "フェイク疑いの初動は「拡散しない」「出所と改変痕跡をチェックする」です。④のように、発信元アカウントの信頼性、メタデータ、フレーム単位の不自然さ、逆画像検索、既存ニュースとの整合など“検証”が先。①の即共有や②の直感判断は誤情報の拡散源になります。③の画質向上は本質的な真偽判定にはなりません。"
                },
                {
                    "q": "生成AIで作った図表に他者の写真を合成し公開する。適切な対応はどれか。",
                    "options": [
                        "研究用途なら無条件可",
                        "自動的に引用に当たる",
                        "権利・同意の確認と表示",
                        "AI生成なので権利なし"
                    ],
                    "answer": 2,
                    "explanation": "他人の写真は「著作権」「肖像権」「（場合により）パブリシティ権」の対象です。AI合成であっても権利は消えません。③のとおり、公開前に“権利者の同意・利用条件・クレジット”等を確認するのが適切。①研究用途でも無条件で自由になるわけではなく、②“自動的に引用”も誤り（引用は主従関係や必要性・出典明示など厳しい要件があります）。④の「AI生成だから権利なし」も誤解です。"
                },
                {
                    "q": "データ拡張（augmentation）の主目的として適切なのはどれか。",
                    "options": [
                        "画像を劣化させる",
                        "過学習の抑制",
                        "学習率の固定",
                        "モデルの凍結"
                    ],
                    "answer": 1,
                    "explanation": "データ拡張は“似ているけど少し違うデータ”を増やして多様性を確保し、②のように過学習を抑えるのが主目的です（回転・切り抜き・色合い変換・ノイズ付与など）。①の“劣化”は目的ではなく、③の学習率や④のモデル凍結は別の学習テクニックです。拡張は「ラベルが変わらない範囲」で行うのがポイント。"
                },
                {
                    "q": "出力の体裁を安定させたい。最も効果が高い指示はどれか。",
                    "options": [
                        "温度を0にする",
                        "例を増やす",
                        "出力形式を明示",
                        "モデルを変更"
                    ],
                    "answer": 2,
                    "explanation": "出力の見た目を揃えるには“出力形式を言葉で固める”のが最強です（見出し、箇条書き、表、JSONキーなどを明示）。③がそれ。①温度0は内容の多様性を抑える手段で体裁の保証には直結しません。②例を増やすのも有効ですが、形式指定ほどの効果は出にくい。④モデル変更は最後の手段です。"
                },
                {
                    "q": "不正競争防止法で「営業秘密」として保護されやすい前提に最も近いのはどれか。",
                    "options": [
                        "公知で有用な情報",
                        "有用だが管理なし",
                        "非公知・有用・管理",
                        "価値は低いが長文"
                    ],
                    "answer": 2,
                    "explanation": "「営業秘密」は一般に①非公知、②有用、③秘密管理の3要件がそろって保護されます。③がそのまとめ。社内ルール・アクセス権・NDA・持ち出し禁止表示など“管理している事実”が重要。①公知情報は対象外、②管理がなければ保護は難しく、④は文章量と無関係です。"
                },
                {
                    "q": "GANの基本構成として正しいのはどれか。",
                    "options": [
                        "EncoderとDecoder",
                        "Attentionのみ",
                        "生成器と識別器",
                        "ルールと事例"
                    ],
                    "answer": 2,
                    "explanation": "GANは「生成器（偽物を作る）×識別器（本物/偽物を見分ける）」が競い合いながら学ぶ構造で③が正解。対立学習により生成器はより“本物らしい”データを作れるようになります。①はVAE等の話、②Attentionのみは別系統、④は学習パラダイムの分類で構成ではありません。"
                },
                {
                    "q": "肖像権とパブリシティ権の違いとして適切なのはどれか。",
                    "options": [
                        "どちらも財産権",
                        "どちらも人格権",
                        "人格権と顧客吸引力の財産権",
                        "両方とも著作権"
                    ],
                    "answer": 2,
                    "explanation": "肖像権は“人が自分の姿をみだりに利用されない権利”（人格権）、パブリシティ権は“著名性や顧客吸引力の経済的価値を守る権利”（財産的権利）です。よって③が適切。①②④は位置付けを取り違えています。実務では“同意取得”と“商業利用か否か”で注意点が変わります。"
                },
                {
                    "q": "VAEの「潜在変数」の役割として正しいのはどれか。",
                    "options": [
                        "出力確率の正規化",
                        "入力の寸法合わせ",
                        "データ本質の圧縮表現",
                        "学習率の調整"
                    ],
                    "answer": 2,
                    "explanation": "VAEの潜在変数は、入力画像の“本質的な特徴”をぎゅっと圧縮して持つ連続的なベクトルです（③）。ここからサンプリングしてデコードすると、新しい画像が滑らかに生成・補間できます。①の正規化はSoftmax等の話、②の寸法合わせは前処理、④の学習率は最適化の話で役割が違います。"
                },
                {
                    "q": "校正依頼プロンプトの設計として効果的なのはどれか。",
                    "options": [
                        "直して、で一文",
                        "誤りだけ列挙",
                        "差分表示と根拠指定",
                        "感想を求める"
                    ],
                    "answer": 2,
                    "explanation": "校正依頼は“どこをどう直したか”が一目で分かることが命。③のように差分表示（Before/After）と根拠（誤字・文法・論理）を求めると、品質確認がラクで、不要な改変も防げます。①「直して」だけでは基準が曖昧、②誤り列挙だけだと直しが反映されず、④感想は校正ではありません。"
                },
                {
                    "q": "生成AIサービスの選定で適切な観点はどれか。",
                    "options": [
                        "ベンチマークのみ",
                        "価格のみ",
                        "目的適合と規約準拠",
                        "流行の有無"
                    ],
                    "answer": 2,
                    "explanation": "サービス選定は“何を達成したいか（目的）に合っているか”“契約・規約・法令に適合するか（データの扱い・ログ・保存・第三者提供等）”“運用できるか（コスト・SLA・拡張性）”の3点を見るのが基本で③が正解。①ベンチマーク単独や②価格のみ、④流行重視は失敗のもとです。"
                },
                {
                    "q": "AI社会原則で重視される視点として最も適切なのはどれか。",
                    "options": [
                        "競争最優先",
                        "透明性や説明責任",
                        "完全自動化の義務",
                        "匿名利用の禁止"
                    ],
                    "answer": 1,
                    "explanation": "AI社会原則の中核は「透明性」と「説明責任」です（②）。“なぜその結果になったのか”“誰がどう管理するのか”を後から説明できる状態にしておくことで、信頼と安全を確保します。①競争最優先は原則ではなく、③完全自動化の義務や④匿名禁止も一般原則ではありません。"
                },
                {
                    "q": "最新情報の取得を前提とするタスクで有効な運用はどれか。",
                    "options": [
                        "モデル単独で断定",
                        "温度のみ調整",
                        "検索や資料指定の併用",
                        "長文を一括投入"
                    ],
                    "answer": 2,
                    "explanation": "最新情報が必要な仕事は、モデル単体の“知識の棚卸し時点”に依存すると危険です。③のように検索や指定資料（URL・PDF・ナレッジベース）を併用し、「根拠の提示」「日付の確認」を促す運用が◎。①断定は誤情報のもと、②温度だけでは事実性は上がらず、④長文丸投げは要点が埋もれます。"
                },
                {
                    "q": "AIガバナンス構築の基本姿勢として適切なのはどれか。",
                    "options": [
                        "事後対応のみ",
                        "一律全面禁止",
                        "リスクベース運用",
                        "完全外部委託"
                    ],
                    "answer": 2,
                    "explanation": "AIガバナンスは“リスクの大きさに応じて対策の強さを調整する”リスクベースが現実的（③）。利用目的・影響範囲・データ種類・外部連携などを評価し、承認フロー・ログ監査・人手確認などを適切に組み合わせます。①事後対応のみは手遅れ、②一律禁止はイノベーションを止め、④丸投げは責任不明確です。"
                },
                {
                    "q": "疑わしい生成動画を受け取った。最も適切な行動はどれか。",
                    "options": [
                        "即時に感想投稿",
                        "切り抜き再編集",
                        "公式ソース照合",
                        "高解像度で再保存"
                    ],
                    "answer": 2,
                    "explanation": "疑わしい動画はまず“裏取り”。③のように公式発表・一次情報・複数の信頼できる報道で照合しましょう。メタデータやフレーム解析、逆画像/動画検索も有効です。①即投稿や②再編集は誤情報の拡散を助長、④高解像度保存は真偽判断に寄与しません。"
                },
                {
                    "q": "業務自動化のためのプロンプト設計で効果的なのはどれか。",
                    "options": [
                        "一文で包括指示",
                        "タスクを段階分解",
                        "乱数で多様化",
                        "長文を丸投げ"
                    ],
                    "answer": 1,
                    "explanation": "業務を自動化するには“人の頭の中の手順”を言語化して段階に分けることが重要です（②）。目的→入力→判定基準→チェック→例外処理…の順にプロンプトを分けると、再現性が上がります。①包括一文は抜け漏れの原因、③乱数で多様化は品質が揺れ、④長文丸投げは意図が伝わりにくいです。"
                },
                {
                    "q": "音声合成（TTS）の適切な利用例として最も妥当なのはどれか。",
                    "options": [
                        "有名人の声で宣伝",
                        "同僚の声の無断複製",
                        "視認困難者向け読み上げ",
                        "課金回避の複製配布"
                    ],
                    "answer": 2,
                    "explanation": "：TTSの適切な利用は“権利と安全への配慮”が前提。③の読み上げ支援のように福祉・アクセシビリティ用途は適合しやすいです。①著名人の声で宣伝や②同僚の声の無断複製は肖像・パブリシティ・プライバシー・契約違反の恐れが高い。④の課金回避の配布は著作権・利用規約違反になり得ます。"
                },
                {
                    "q": "【時事】Anthropicの「Claude Opus 4.1」（2025年8月リリース）に関する正しい記述はどれか。",
                    "options": [
                        "無料ユーザー限定の提供",
                        "価格はOpus 4と同じ",
                        "画像非対応の後退版",
                        "API未提供の試験版"
                    ],
                    "answer": 1,
                    "explanation": "この設問の要点は「新バージョン（Opus 4.1）が機能強化しつつ、提供形態や価格を据え置いた」という理解にあります。②はその趣旨を押さえています。①“無料限定”は上位モデルの提供形態として不自然、③“画像非対応の後退”は新バージョンの方向性と逆、④“API未提供の試験版”ではエンタープライズ活用に結びつきません。新モデルは“互換性と移行のしやすさ”も評価ポイントです。"
                }
            ]
        }
    ];

    const quizContainer = document.getElementById('quiz-container');
    let userState = {}; // { qIndex: { answer: number, flagged: boolean } }
    let currentFilter = 'all';

    function renderQuiz() {
        quizContainer.innerHTML = '';
        quizData.forEach((section, sectionIndex) => {
            const sectionHeader = document.createElement('h2');
            sectionHeader.textContent = section.section;
            quizContainer.appendChild(sectionHeader);

            section.questions.forEach((question, qIndex) => {
                const globalIndex = quizData.slice(0, sectionIndex).reduce((acc, s) => acc + s.questions.length, 0) + qIndex;
                const questionBlock = document.createElement('div');
                questionBlock.className = 'question-block';
                questionBlock.id = `q-${globalIndex}`;
                
                const questionTitle = document.createElement('div');
                questionTitle.className = 'question-title';
                questionTitle.textContent = `Q${globalIndex + 1}. ${question.q}`;

                const flagButton = document.createElement('button');
                flagButton.className = 'flag-button';
                flagButton.innerHTML = '🚩';
                flagButton.onclick = () => toggleFlag(globalIndex);
                if (userState[globalIndex] && userState[globalIndex].flagged) {
                    flagButton.classList.add('flagged');
                }
                
                questionBlock.appendChild(flagButton);
                questionBlock.appendChild(questionTitle);
                
                const optionsDiv = document.createElement('div');
                optionsDiv.className = 'options';
                question.options.forEach((option, oIndex) => {
                    const optionLabel = document.createElement('label');
                    const radioInput = document.createElement('input');
                    radioInput.type = 'radio';
                    radioInput.name = `question-${globalIndex}`;
                    radioInput.value = oIndex;
                    optionLabel.appendChild(radioInput);
                    optionLabel.appendChild(document.createTextNode(option));
                    optionsDiv.appendChild(optionLabel);
                });
                questionBlock.appendChild(optionsDiv);

                const gradeButton = document.createElement('button');
                gradeButton.className = 'grade-button';
                gradeButton.textContent = '回答する';
                gradeButton.onclick = () => showAnswer(globalIndex, question.answer, question.explanation);
                questionBlock.appendChild(gradeButton);

                const answerSection = document.createElement('div');
                answerSection.className = 'answer-section';
                answerSection.id = `answer-${globalIndex}`;
                questionBlock.appendChild(answerSection);
                
                quizContainer.appendChild(questionBlock);
            });
        });
        loadState();
        updateScore();
        applyFilter(currentFilter);
    }

    function showAnswer(qIndex, correctAnswer, explanation) {
        const questionBlock = document.getElementById(`q-${qIndex}`);
        const answerSection = document.getElementById(`answer-${qIndex}`);
        const radioInputs = document.getElementsByName(`question-${qIndex}`);
        let userAnswer = -1;
        radioInputs.forEach((input, index) => {
            if (input.checked) userAnswer = index;
        });

        if (!userState[qIndex]) userState[qIndex] = { answer: -1, flagged: false };
        userState[qIndex].answer = userAnswer;
        saveState();

        answerSection.innerHTML = '';

        if (userAnswer === correctAnswer) {
            answerSection.innerHTML += `<div class="answer-header answer-correct">✅ 正解です！</div>`;
        } else {
            const selectedOptionText = userAnswer !== -1 ? `あなたが選択した答え: ${quizData[getSectionIndex(qIndex)].questions[qIndex - quizData.slice(0, getSectionIndex(qIndex)).reduce((acc, s) => acc + s.questions.length, 0)].options[userAnswer]}` : '未回答';
            answerSection.innerHTML += `<div class="answer-header answer-incorrect">❌ 不正解です。</div>`;
            answerSection.innerHTML += `<div class="explanation">${selectedOptionText}</div>`;
        }
        answerSection.innerHTML += `<div class="explanation"><strong>正解は「${quizData[getSectionIndex(qIndex)].questions[qIndex - quizData.slice(0, getSectionIndex(qIndex)).reduce((acc, s) => acc + s.questions.length, 0)].options[correctAnswer]}」です。</strong></div>`;
        answerSection.innerHTML += `<div class="explanation"><strong>【解説】</strong>${explanation}</div>`;
        answerSection.style.display = 'block';

        questionBlock.querySelector('.grade-button').style.display = 'none';
        radioInputs.forEach(input => input.disabled = true);
        updateScore();
    }

    function toggleFlag(qIndex) {
        if (!userState[qIndex]) userState[qIndex] = { answer: -1, flagged: false };
        userState[qIndex].flagged = !userState[qIndex].flagged;
        
        const flagButton = document.querySelector(`#q-${qIndex} .flag-button`);
        flagButton.classList.toggle('flagged', userState[qIndex].flagged);
        
        saveState();
    }
    
    function updateScore() {
        let correctCount = 0;
        let answeredCount = 0;
        const totalQuestions = quizData.reduce((acc, s) => acc + s.questions.length, 0);

        for (let i = 0; i < totalQuestions; i++) {
            if (userState[i] && userState[i].answer !== -1) {
                answeredCount++;
                const sectionIndex = getSectionIndex(i);
                const qInSectionIndex = i - quizData.slice(0, sectionIndex).reduce((acc, s) => acc + s.questions.length, 0);
                const correctAnswer = quizData[sectionIndex].questions[qInSectionIndex].answer;
                if (userState[i].answer === correctAnswer) {
                    correctCount++;
                }
            }
        }
        
        const accuracy = answeredCount > 0 ? (correctCount / answeredCount) * 100 : 0;
        
        document.getElementById('correct-count').textContent = correctCount;
        document.getElementById('answered-count').textContent = answeredCount;
        document.getElementById('accuracy-rate').textContent = accuracy.toFixed(1);
    }

    function applyFilter(filter) {
        currentFilter = filter;
        const questionBlocks = document.querySelectorAll('.question-block');
        questionBlocks.forEach((block, qIndex) => {
            const state = userState[qIndex] || { answer: -1, flagged: false };
            const sectionIndex = getSectionIndex(qIndex);
            const qInSectionIndex = qIndex - quizData.slice(0, sectionIndex).reduce((acc, s) => acc + s.questions.length, 0);
            const correctAnswer = quizData[sectionIndex].questions[qInSectionIndex].answer;
            
            let show = false;
            switch (filter) {
                case 'all':
                    show = true;
                    break;
                case 'flagged':
                    if (state.flagged) show = true;
                    break;
                case 'unanswered':
                    if (state.answer === -1) show = true;
                    break;
                case 'correct':
                    if (state.answer !== -1 && state.answer === correctAnswer) show = true;
                    break;
                case 'incorrect':
                    if (state.answer !== -1 && state.answer !== correctAnswer) show = true;
                    break;
            }
            block.style.display = show ? 'block' : 'none';
        });
        
        document.querySelectorAll('.filter-button').forEach(btn => btn.classList.remove('active'));
        document.querySelector(`.filter-button[onclick="applyFilter('${filter}')"]`).classList.add('active');
    }

    function getSectionIndex(qIndex) {
        let count = 0;
        for (let i = 0; i < quizData.length; i++) {
            count += quizData[i].questions.length;
            if (qIndex < count) return i;
        }
    }

    function saveState() {
        localStorage.setItem('userQuizState', JSON.stringify(userState));
    }

    function loadState() {
        const savedState = localStorage.getItem('userQuizState');
        if (savedState) {
            userState = JSON.parse(savedState);
            Object.keys(userState).forEach(qIndexStr => {
                const qIndex = parseInt(qIndexStr, 10);
                const state = userState[qIndex];
                if (state.answer !== -1) {
                    const radioInput = document.querySelector(`input[name="question-${qIndex}"][value="${state.answer}"]`);
                    if (radioInput) {
                        radioInput.checked = true;
                        const sectionIndex = getSectionIndex(qIndex);
                        const qInSection = qIndex - quizData.slice(0, sectionIndex).reduce((acc, s) => acc + s.questions.length, 0);
                        showAnswer(qIndex, quizData[sectionIndex].questions[qInSection].answer, quizData[sectionIndex].questions[qInSection].explanation);
                    }
                }
            });
        }
    }
    
    function exportState() {
        if (Object.keys(userState).length === 0) {
            alert("エクスポートする回答データがありません。");
            return;
        }
        const data = JSON.stringify(userState);
        const encodedData = btoa(encodeURIComponent(data));
        navigator.clipboard.writeText(encodedData)
            .then(() => alert("回答状況がクリップボードにコピーされました！"))
            .catch(err => alert("回答状況のコピーに失敗しました。"));
    }

    function showImport() {
        document.getElementById('import-area').style.display = 'block';
    }

    function importState() {
        const importInput = document.getElementById('import-input');
        const statusMessage = document.getElementById('status-message');
        try {
            const decodedData = decodeURIComponent(atob(importInput.value));
            userState = JSON.parse(decodedData);
            saveState();
            renderQuiz();
            statusMessage.textContent = '回答状況をインポートしました！';
            statusMessage.style.color = '#28a745';
        } catch (e) {
            statusMessage.textContent = '無効なデータです。インポートに失敗しました。';
            statusMessage.style.color = '#dc3545';
        }
    }

    function clearState() {
        if (confirm('全ての回答状況をクリアしますか？')) {
            localStorage.removeItem('userQuizState');
            userState = {};
            currentFilter = 'all';
            renderQuiz();
            alert('全ての回答状況がクリアされました。');
        }
    }

    document.addEventListener('DOMContentLoaded', renderQuiz);
</script>

</body>
</html>